[あなたのコードがどのように動作するのか、簡潔に説明してください。]

# コード動作

1. parseArgs 関数で引数を確認します。不正な引数が入っていたらエラーを返して終了します。
2. solver.solve メソッドでロジックを実行します。
3. ロジック上APIへの接続が必要な部分は、askRepository(Impl).Ask 関数でAPIへのリクエストとレスポンスデータの確認を行います。

# 工夫した点

* solver, repository はstructとすることで、テスト時にモックを用いたテストを可能としています
* API実行結果をrepository 内部に持つことで、solverからは隠蔽しました。
* が、結局 solver側の偶数時処理が重いので、ここでもキャッシュを活用しています。n=100以上のときに実行速度が気になり始める(1秒以上かかる)ので、実際のユースケースの想定次第ではキャッシュをsolver側に集約するのが賢いかもしれません。(テストでユースケースもなにもないので、一旦そのままにしています)

# 発生した問題、難しかった箇所

* APIレスポンスが約100msと遅いので、並列処理にしたかったのですが、時間制限もあって諦めました。以下それぞれのケースを考慮しなければいけないので、なかなか難易度が高そうです。
  1. 既にそのnでAPIを叩いていて、結果が帰ってきた
  2. 既にそのnでAPIを叩いていて、結果待ち
  3. はじめてそのnでAPIを叩いて、正常に結果が帰ってきた場合
  4. はじめてそのnでAPIを叩いて、異常な結果が帰ってきた場合(他の並列実行プロセスをすべて落とす必要がある)
* 上記考慮で時間を使ってしまい、主にキャッシュ周りのリファクタリングを実行する時間が足りませんでした。